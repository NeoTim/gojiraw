# Image
An `Image` is an `Inkings` augmented with an optional rectangular
expanse of pixels that can be the target of GPU rasterization or the
source for scanout to the `Display` These pixels are not inside the
Image structure. Instead, the system (i.e. GPU) owns the actual
pixels.

It is possible that we must support referring to the underlying pixel
data in two different processes. If so, we need a mechanism to pass
image data handles between processes using an operating system
appropriate mechanism such as `gralloc` buffers or `IOSurface`
objects. We should however attempt to satisfy the needs of Gojiraw
clients without providing such a facility as (at least in my opinion)
inter-process GPU image transport has brought enormous complexity to
Chrome.

When overlays are available, a presentable `Image` will own no pixel
data itself. Instead, it will contain (as it is an `Inkings`) one or
more children `Image` objects that each have their own GPU-resident
pixel data that will be used for scanout.

```go
const (
	_ = iota
	OverlayCandidate = iota
)

type Image interface {
	Load(r Rectangle, data []byte, opts ...interface{}) <-channel error
	Unload(r Rectangle, data []byte, opts ...interface{}) <-channel error
	Release()
	NewImage(r Rectangle, opts ...interface{}) (Image, error)
}

func Zero() Image
```

## LoadImage
`Load` fills `Rectangle r` with pixel `data` as controlled by the
additional configuration options. The routine returns immediately. The
returned channel indicates when the uploading process has completed.

Options specify stride, packing etc. as suggested by the arguments to
`glTexSubImage2D`.

- [ ] Am I providing a rich enough API surface for copy minimization
- [ ] I need to refine and make precise how we can determine and take
advantage of hardware support for image conversion (decompression for
example) during the execution of a `Load` operation.
- [ ] The error should be available synchronously.

## Unload
`Unloadimage` reads a rectangle of pixels from the target `Image` and writes
it  into data as controlled by the options. The returned channel indicates when
the uploading process has completed.

## Release
`Release` explicitly relinquishes the storage underlying this `Image`. Rational: GPU
image data is large, GPU memory is frequently special and/or in short supply.
So provide a mechanism to explicitly indicate when the memory backing
an `Image` is no longer needed.

## NewImage
`NewImage` creates an `Image` as specified by the provided options.
Options include the `OverlayCandidate` to indicate that this `Image`
should have backing storage allocated in a fashion that it could be a
scanout source. 

The created `Image` object will use the same GPU pixel storage as
the target object.

Attempting to render an `Image` object to an `Image` that does not share
the same GPU storage will fail. 

- [ ] Specify when this failure is detected and indicated.

# Display
`Display` contains state about the connected graphics system.
A `Display` is also an `Image`. A `Display` containing multiple screens will
have several different child `Display` objects corresponding to the actual
screens.

- [ ] This section  ignores that screens can refresh at different rates and
that the Display could be generated by multiple different GPUs. Address.

```go
type RefreshDeadline struct {
	VblankEnd time.Duration
	NextVblankEnd time.Duration
}

type ScreenInfo struct {
	// TBD
}

type Display interface {
	Image
	RefreshDeadlineChannel() <-channel RefreshDeadline
	Screens() []Display
	ScreensInfo() []ScreenInfo
}

NewMockDisplay(opts ...interface{}) Display
NewDisplay(opts ...interface{}) Display
```

## RefreshDeadlineChannel
`RefreshDeadlineChannel` returns a channel that becomes ready on 
the start of a vblank and provides the `time.Duration` into the future
of the end of the vblank interval and the end of the *next vblank*.

## Screens
`Screens` return the children `Display` objects, one for each
physically attached screen. Enumerate the size of actual monitors on
the system like this:

```go

display := NewDisplay(/* details elided */)
for i, s := range display.Screens() {
	r := s.Bound()
	fmt.Printf("[%d] x %f y  %f w %f  h %f", i, r.min.x, r.min.y, r.max.x - r.min.x, r.max.y - r.min.y)
}
```

## ScreensInfo
`ScreensInfo` returns an array of additional information for each attached screen.

## Discussion
Create an `Image` for by using `NewImage` on a `Display`. In the multiple screens
case, it will be an error to attempt to do so on the top-level `Display` object.

`NewMockDisplay()` returns a `Display` whose `Image` objects are memory
resident and cannot be used for scanout. For example, the following
code fragment would provide functionality resembling the ozone files
backend.

```go
model := NewInkings()
tick := 0
display := NewMockDisplay()

for {
	select {
	case e := <-getNextEvent():
		appUpdatesModelForEvent(model, e)
	case <-time.Tick(time.Millisecond * 16):
		snapshot := <-ink.Clone()
		go func(snapshot Inkings, tick int) {
			r := geom.Rect{geom.Point{0,0}, geom.Point{1024, 768}}
			image, _ := display.NewImage(r)
			<-snapshot.Render(image)
			buf := make([]byte, 1024 * 768 * 4)
			<-image.Unload(buf, r, /* options for packed, contiguous, alpha, etc. */)
			ioutil.WriteFile(fmt.Sprintf("frame_%d", tick), buf, 0x644)
		}
		tick += 1
	}
}
```

`Show` on a `Display` object has different semantics than it does on
an arbitrary `Inkings` In particular: it sets the display controller
to scanout from the provided `Image` immediately. Users of the entry
point wishing to avoid tearing should use the
`RefreshDeadlineChannel()` channel to limit these `Show` calls to
inside the vblank interval.

```go
display := NewDisplay() // Assume one screen.
model := NewInkings()

// This would compile but is silly.
display.Render(display)

// Make a new Image.
image := display.NewImage(Rect{{0,0}, {1024,768}})

// Add enzo to image...

// This is allowed. Only image Enzo corresponding to overlay
// planes remain.
<-image.Render(image)

// Show on a display means that display hardware is now scanning
// out from image. 
<-display.Show(image)

// This code executes on the vblank after the frame in which image
// was the scanout source.
fmt.Printf("hello")
```

